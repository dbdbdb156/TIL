# Union-Find
for disjoint set

###  상호 배타적 집합(disjoint set) 이란?
:공통 원소가 없는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조

#### 기능
- 초기화 : n개의 원소가 각각 집합에 포함되 있도록
- 합치기(union) : 원소 a,b 가 속한 두 집합을 하나로 합침
- 찾기(find) : 원소 a 가 속한 집합 반환

#### 1. 배열로 표현
- 배열 순회에 O(n) , 합치기 연산 시간이 오래걸림

### 2. 트리로 상호배타적 집합 표현

#### 찾기연산 : 원소가 포함된 트리의 루트 찾기
; 통상적인 트리와 반대로 자식이 부모에 대한 정보만 가지고 있는 것이 특징, 루트는 자기자신

#### 합치기 연산 : 각 트리의 루트를 찾은 뒤, 하나를 다른 한쪽의 자손으로 넣음
** 한 노드를 다른 노드의 자식으로 넣기 전에 먼저 양 트리의 루트를 찾아야 한다

#### 최적화
1. struct 자료형에 rank[] 을 선언하여, depth도 체크해준다.
이후, 합치기를 할때, 긴 트리에 짧은 트리를 연결한다. 만약 depth 가 같으면 rank[] 를 더하기 해준다.
- 시간복잡도 : O(logN)

2. 경로 압축
: parent[] 를 찾아낸 루트로 아예 바꿔 버리면 다음번에 find() 가 호출 되었을때는 경로를 따라 갈 필요없이 바로 루트로 감

3. 1,2 둘다 적용한 disjoint set
- find 연산은 호출마다 수행시간 바뀌기에 분할 상환 분석 이용 ( 
* 분할상환분석: 주어진 알고리즘의 시간 복잡도나 프로그램을 수행하는데 소요되는 시간 또는 메모리 같은 자원 사용량을 분석하기 위해서 사용하는 기법이다
- 걸리는 평균시간 : O(a(n)), 현실적인 모든 입력에 대해 상수 시간에 동작, 애커만 함수 사용(엄청 빠르게 증가함)

ex) 최소 스패닝 트리 알고리즘

의의) 
- 중복되는 원소가 없는 집합을 트리로서 관리 할수 있다는것.
- disjoint 를 사용하는 예제를 통해서 사용하는 방법 






