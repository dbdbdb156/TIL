# Java 내 멀티쓰레딩 : 하나의 프로세스 안에서 여러개의 스레드가 동시에 작업 수행
### * 구현 방법 : 둘다 run() 메소드를 오버라이딩 하는 방식
1) Runnable 인터페이스 구현
- 해당 클래스를 인스턴스화 해서 Thread 생성자에 argument 로 넘겨줘야함
- run()을 호출하면 Runnable 의 구현 run()이 호출되어 오버라이딩 안해도됨
- currentThread()를 호출해서 스레드 클래스에 대한 참조해야함.
<예제 코드>
Runnable r = new MyThread();
Thread t = new Thread(r, "mythread");

2) Thread 클래스 상속
- 상속받은 클래스 자체를 스레드로 사용 가능
- 스레드 클래스의 메소드 바로 사용 가능

- 스레드의 실행은 start()로 실행해야함. ( run() 아님)
: 똑같은 업무를 한것이지만 스레드를 사용한 것은 아님.
- start() 함수를 사용해야 JVM이 스레드를 위한 콜스택도 만들어 주고 Context Switching을 통해 스레드답게 동작

* 콜스택 : 실질적인 명령어들을 담고 있는 메모리. 하나씩 꺼내서 실행시킴.
** 스레드 사용 = JVM이 다수의 콜 스택을 번갈아가며 일처리를 하는 것.

## 스레드의 상태 : 5가지
1) NEW : 스레드가 생성되고 아직 start가 호출되지 않은 상태
2) RUNNABLE: 실행 중 또는 실행 가능 상태
3) BLOCKED : 동기화 블록에 의해 일시정지된 상태(lock이 풀릴 때까지 기다림)
4) WAITING, TIME_WAITNG : 실행가능하지 않은 일시적인 상태
5) TERMINATE : 스레드 작업이 종료된 상태

### * 동기화
: 여러 스레드가 같은 프로세스 내 자원을 공유하면서 다른 작업에 영향을 주기 때문이다.
- 임계영역을 지정하고, 임계영역이 가지고 있는 lock을 단 하나의 스레드에게 주는 개념 사용, 임계구역안에 수행할 코드가 완료되면 lock 반납
### * 스레드 동기화 방법
- 임계 영역(Criticla section) : 공유 자원에 단 하나의 스레드만 접근하도록
- 뮤텍스 : 공유 자원에 단 하나의 스레드만 접근하도록
- 이벤트 : 특정한 사건 발생을 다른 스레드에게 알림
- 세마포어 : 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때 접근 제한
- 대기 가능 타이머 : 특정 시간이 되면 대기중이던 스레드 깨움

### * synchronized 활용
: synchronized 로 임계영역을 설정할수 있음
- 쓰레드가 서로 협력 관계일때는 무작정 대기 시키는 것으로 올바르게 실행되지 않는다.
ex) Thread.sleep(2000)  

* wait()와 notify() 활용
- wait() : 스레드가 lock을 가지고 있으면, lock 권한을 반납하고 대기하게 만듬

### * 스레드 실행 제어 함수
- sleep() : 지정된 시간동안 스레드 일시정지, 시간이 지나고 난후에 실행대기상태
 1) sleep 메소드는 인스턴드 메소드가 아니라 클래스 메소드(static )이다. 메소드가 동작하는 포인트는 현재 실행중인 Thread 이다.
즉, t1.sleep() 이 아니라, Thread.sleep()을 실행해야 대기열에 먼저 올라간 th1 쓰레드가 영향 받는다. 즉, 스레드 구현 클래스 안에 Thread.sleep() 을 걸어야 한다.

- join() : 지정된 시간동안 스레드가 실행되도록 한다. 지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 스레드로 돌아와 실행을 계속한다.
- interrupt() : sleep()이나 join()에 의해 일시정지 된 스레드를 깨워서 실행대기상태로 만듬
- suspend() : 스레드를 일시정지시킨다. resume()이 호출되어야 실행대기 상태가 된다.
- resume() : suspend() 의해 정지된 스레드를 다시 실행대기상태로 복구한다.
- yield() : 실행 중에 자신에게 주어진 실행시간을 다른 스레드에게 양보하고 자신은 실행대기
+ 추가
- wait() : 스레드가 lock을 가지고 있으면 lock 권한을 반납하고 대기하게 만듬
- notify() : 대기상태인 스레드에게 다시 lock 권한을 부여하고 수행하게 만듬

### * 스레드의 생명주기
1. 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어 자신의 차례가 될 때까지 기다린다. (RUNNABLE인 상태의 쓰레드가 여러개 존재 가능)
2. 실행대기상태에 있다가 자신의 차례가 되면 실행상태가 된다.
3. 주어진 실행시간이 다되거나 yield()를 만나면 다시 실행대기상태가 되고 다음 차례의 쓰레드가 실행상태가 된다.
4. 실행 중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지상태가 될 수 있다.
5. 지정된 일시정지시간이 다되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나 다시 실행대기열에 저장되어 자신의 차례를 기다린다.
6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸된다.
